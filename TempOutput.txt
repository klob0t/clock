#include <Arduino.h>
#include <MD_Parola.h>
#include <MD_MAX72xx.h>
#include <SPI.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include "time.h"
#include "BitPotionFont.h"
#include "MilfordFont.h"
#include "config.h"
#include "time_service.h"
#include "weather_service.h"
#include "display_clock.h"
#include "display_weather.h"
#include "display_sun.h"
#include "display_scope.h"
#include "animations.h"

// =============================================================================
// 1. STATE
// =============================================================================

unsigned long lastWeatherCheck = 0;
unsigned long weatherCheckInterval = WEATHER_CHECK_INTERVAL;

#define HARDWARE_TYPE MD_MAX72XX::FC16_HW
#define MAX_DEVICES 5
#define CS_PIN 5

// 3 ZONES:
// ZONE 0: Clock (Modules 2-4)
// ZONE 1: Weather Desc (Modules 1-3)
// ZONE 2: Temp (Module 0)
MD_Parola P(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);
MD_MAX72XX *mx;
WiFiUDP controlUdp;
WiFiUDP audioUdp;

static const int TOTAL_WIDTH = 40;
static const int HUD_WIDTH = 16;
uint8_t screenBuffer[TOTAL_WIDTH];

// =============================================================================
// 2. ENUMS & STATES
// =============================================================================
enum PageState
{
  PAGE_CLOCK,
  TRANS_TO_WEATHER,
  PAGE_WEATHER,
  TRANS_TO_SUN,
  PAGE_SUN,
  TRANS_TO_SCOPE,
  PAGE_SCOPE,
  TRANS_TO_CLOCK
};

// =============================================================================
// 3. VARIABLES & BITMAPS
// =============================================================================

// 5-PIXEL TALL BITMAPS (Stored in Bytes 4,3,2,1,0)
const uint64_t DIGITS[] = {
    0x0000000305050506,
    0x0000000702020302,
    0x0000000702040507,
    0x0000000704020407,
    0x0000000404060505,
    0x0000000205040307,
    0x0000000205050306,
    0x0000000202040407,
    0x0000000705020507,
    0x0000000306050502};
const uint64_t LETTERS[] = {
    0x0000000505020505,
    0x0000000505050707,
    0x0000000305050506,
    0x0000000101030107,
    0x0000000202020207,
    0x0000000605050505,
    0x0000000701030107,
    0x0000000707050505,
    0x0000000705050503,
    0x0000000505070505,
    0x0000000505030503,
    0x0000000702020207,
    0x0000000704060107,
    0x0000000505070503,
    0x0000000505050503};
const uint8_t DAY_MAP[8][3] = {
    {0, 0, 0}, {12, 5, 14}, {1, 2, 14}, {4, 5, 6}, {7, 6, 8}, {4, 9, 5}, {3, 10, 11}, {12, 13, 4}};
constexpr int WEATHER_ICON_COUNT = 9;
enum WeatherIcon : uint8_t
{
  ICON_HEAVY_RAIN = 0,
  ICON_CLEAR = 1,
  ICON_FEW_CLOUDS = 2,
  ICON_BROKEN_CLOUDS = 3,
  ICON_THUNDERSTORM = 4,
  ICON_UNKNOWN = 5,
  ICON_DRIZZLE = 6,
  ICON_ATMOSPHERE = 7,
  ICON_SNOW = 8
};
const uint8_t WEATHER_ICONS[WEATHER_ICON_COUNT][8] = {
    {24, 36, 6, 175, 113, 42, 10, 28},
    {24, 102, 66, 129, 129, 66, 102, 24},
    {48, 72, 72, 72, 80, 84, 68, 56},
    {48, 72, 76, 82, 82, 68, 68, 56},
    {24, 36, 6, 165, 113, 42, 2, 28},
    {32, 92, 84, 90, 74, 68, 76, 56},
    {144, 110, 42, 45, 165, 98, 38, 28},
    {80, 81, 85, 69, 17, 20, 84, 68},
    {66, 195, 60, 36, 36, 60, 195, 66}};

const uint64_t MOON_SUN[] = {
    0x1866428181426618, // sun fully in the sky (mid-day)
    0xff42818142661800, // sun 1 row lower
    0xff81814266180000, // sun 2 rows lower
    0xff81426618000000, // sun 3 rows lower
    0xff42661800000000, // sun 4 rows lower
    0xff66180000000000, // sun 5 rows lower
    0xff18000000000000, // sun 6 rows lower
    0xff00000000000000, // horizon only (________) (exactly at sunset/sunrise)
    0x3c4688909088463c, // moon fully in  the sky (mid-night)
    0xff48909088463c00, // moon 1 row lower
    0xff909088463c0000, // moon 2 rows lower
    0xff9088463c000000, // moon 3 rows lower
    0xff88463c00000000, // moon 4 rows lower
    0xff463c0000000000, // moon 5 rows lower
    0xff3c000000000000  // moon 6 rows lower
  };

// --- VARS ---
bool showColon = true;
int lastSecond = -1;
DateMode currentMode = MODE_DATE;
DateMode nextMode = MODE_DAY;
unsigned long modeTimer = 0;
uint64_t targetBitmaps[4];
int resolveFrame[4];
int currentFrame = 0;

int scrambleIndices[4];

unsigned long lastScrambleTick = 0;
const int SCRAMBLE_DELAY = 25;

PageState currentPage = PAGE_CLOCK;
unsigned long pageTimer = 0;
bool triggerZoneSetup = true;

// Clock page bounce dot on module 1 (cols 8-15)
const int BOUNCE_START_COL = 0;
const int BOUNCE_END_COL = 15;
float bouncePos = BOUNCE_START_COL;
float bounceVel = 0.0f;
const float BOUNCE_G_MAG = 58.0f;       // cols/s^2 toward the ground (left)
const float BOUNCE_LAUNCH_V = 40.0f;    // initial rightward launch speed
const unsigned long BOUNCE_MAX_DT = 40; // clamp dt to avoid big jumps
unsigned long lastBounceTick = 0;

// Weather
uint8_t weatherIconID = ICON_CLEAR;
String weatherDesc = "Init...";
int feelsLikeTemp = 0;
char weatherTextBuffer[60];
char tempTextBuffer[10];
unsigned long sunriseEpoch = 0;
unsigned long sunsetEpoch = 0;
char sunTextBuffer[60];
uint8_t scopeSamples[TOTAL_WIDTH];
bool scopeHasData = false;
unsigned long lastScopePacketMs = 0;
float scopeSmoothed[TOTAL_WIDTH];

struct tm timeinfo;

// =============================================================================
// 4. FORWARD DECLARATIONS
// =============================================================================
void updateLocalTime();
int getDay();
int getMonth();
int getWeekday();
int getMinute();
int getSecond();
int getHour();
void getWeatherData();
void drawGlitch();
void startScrambleTransition(DateMode destination);
void updateModeSwitcher(unsigned long nowMs);
void updatePageLogic(unsigned long nowMs);
void updateDisplay(unsigned long nowMs);
void forcePage(PageState target, unsigned long nowMs, bool withTransition = true);
void handleControlPackets(unsigned long nowMs);
void handleAudioPackets(unsigned long nowMs);

// =============================================================================
// 5. SETUP
// =============================================================================
void setup()
{
  Serial.begin(115200);

  P.begin(3);
  P.setIntensity(DISPLAY_INTENSITY);

  // DEFINE INITIAL ZONES (Page 1)
  P.setZone(0, 2, 4);
  P.setZone(1, 0, 0);
  P.setZone(2, 0, 0);

  mx = P.getGraphicObject();

  WiFi.setHostname(MDNS_HOSTNAME);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED)
    delay(100);
  Serial.print("WiFi connected. IP: ");
  Serial.println(WiFi.localIP());
  if (!MDNS.begin(MDNS_HOSTNAME))
    Serial.println("mDNS start failed");
  else
  {
    MDNS.addService("udp", "udp", CONTROL_UDP_PORT);
    MDNS.addService("audio", "udp", AUDIO_UDP_PORT);
  }
  controlUdp.begin(CONTROL_UDP_PORT);
  audioUdp.begin(AUDIO_UDP_PORT);

  initTime(NTP_SERVER, GMT_OFFSET_SEC, DAYLIGHT_OFFSET_SEC);
  while (!getTimeState(500).valid)
    delay(100);

  getWeatherData();
  pageTimer = millis();
}

void loop()
{
  unsigned long nowMs = millis();

  if (nowMs - lastWeatherCheck > weatherCheckInterval)
  {
    getWeatherData();
    lastWeatherCheck = nowMs;
  }

  handleControlPackets(nowMs);
  handleAudioPackets(nowMs);
  updatePageLogic(nowMs);
  updateDisplay(nowMs);
}

// =============================================================================
// 6. FUNCTIONS
// =============================================================================

void updateLocalTime()
{
  TimeState ts = getTimeState();
  if (ts.valid)
    timeinfo = ts.now;
}
int getDay() { return timeinfo.tm_mday; }
int getMonth() { return timeinfo.tm_mon + 1; }
int getWeekday() { return timeinfo.tm_wday + 1; }
int getHour() { return timeinfo.tm_hour; }
int getSecond() { return timeinfo.tm_sec; }
int getMinute() { return timeinfo.tm_min; }

void getWeatherData()
{
  if (WiFi.status() != WL_CONNECTED)
  {
    weatherDesc = "No WiFi";
    weatherIconID = ICON_UNKNOWN;
    feelsLikeTemp = 0;
    sunriseEpoch = 0;
    sunsetEpoch = 0;
    return;
  }

  WeatherData data = fetchWeather(OWM_API_KEY, LATITUDE, LONGITUDE);
  if (data.valid)
  {
    int id = data.id;
    weatherDesc = data.desc;
    feelsLikeTemp = data.feelsLike;
    sunriseEpoch = data.sunrise;
    sunsetEpoch = data.sunset;

    if (id >= 200 && id <= 232)
      weatherIconID = ICON_THUNDERSTORM;
    else if (id >= 300 && id <= 321)
      weatherIconID = ICON_DRIZZLE;
    else if (id >= 500 && id <= 501)
      weatherIconID = ICON_DRIZZLE;
    else if (id >= 502 && id <= 531)
      weatherIconID = ICON_HEAVY_RAIN;
    else if (id >= 600 && id <= 622)
      weatherIconID = ICON_SNOW;
    else if (id >= 700 && id <= 781)
      weatherIconID = ICON_ATMOSPHERE;
    else if (id == 800)
      weatherIconID = ICON_CLEAR;
    else if (id == 801 || id == 802)
      weatherIconID = ICON_FEW_CLOUDS;
    else if (id == 803 || id == 804)
      weatherIconID = ICON_BROKEN_CLOUDS;
    else
      weatherIconID = ICON_UNKNOWN;
  }
  else
  {
    weatherDesc = "No Data";
    weatherIconID = ICON_UNKNOWN;
    sunriseEpoch = 0;
    sunsetEpoch = 0;
  }
}

void drawGlitch()
{
  for (int i = 0; i < TOTAL_WIDTH; i++)
  {
    if (random(0, 10) > 6)
      screenBuffer[i] = random(0, 255);
    else
      screenBuffer[i] = 0;
  }
  if (random(0, 10) > 8)
  {
    int start = random(0, 32);
    for (int k = 0; k < 8; k++)
      screenBuffer[start + k] = ~screenBuffer[start + k];
  }
}

void startScrambleTransition(DateMode destination)
{
  currentMode = MODE_SCRAMBLE;
  nextMode = destination;
  currentFrame = 0;
  modeTimer = millis();
  updateLocalTime();
  int d = getDay();
  int m = getMonth();
  int wd = getWeekday();
  if (destination == MODE_DATE)
  {
    targetBitmaps[0] = DIGITS[d / 10];
    targetBitmaps[1] = DIGITS[d % 10];
    targetBitmaps[2] = DIGITS[m / 10];
    targetBitmaps[3] = DIGITS[m % 10];
  }
  else
  {
    targetBitmaps[0] = LETTERS[DAY_MAP[wd][0]];
    targetBitmaps[1] = LETTERS[DAY_MAP[wd][1]];
    targetBitmaps[2] = LETTERS[DAY_MAP[wd][2]];
    targetBitmaps[3] = 0;
  }
  for (int i = 0; i < 4; i++)
  {
    resolveFrame[i] = random(20, 60);   // (Kept your longer duration)
    scrambleIndices[i] = random(0, 15); // <--- ADD THIS: Seed initial random char
  }
}

void updateModeSwitcher(unsigned long nowMs)
{
  if (currentMode == MODE_SCRAMBLE)
    return;
  if (nowMs - modeTimer > 3000UL)
  {
    DateMode dest = (currentMode == MODE_DATE) ? MODE_DAY : MODE_DATE;
    startScrambleTransition(dest);
  }
}

void updatePageLogic(unsigned long nowMs)
{
  unsigned long duration = nowMs - pageTimer;

  switch (currentPage)
  {
  case PAGE_CLOCK:
    if (duration > CLOCK_PAGE_DURATION_MS)
    {
      currentPage = TRANS_TO_WEATHER;
      pageTimer = nowMs;
      P.displayClear();
    }
    break;

  case TRANS_TO_WEATHER:
    if (duration > PAGE_TRANSITION_MS)
    {
      currentPage = PAGE_WEATHER;
      pageTimer = nowMs;
      triggerZoneSetup = true;
    }
    break;

  case PAGE_WEATHER:
    if (duration > WEATHER_PAGE_DURATION_MS)
    {
      currentPage = TRANS_TO_SUN;
      pageTimer = nowMs;
      P.displayClear();
    }
    break;

  case TRANS_TO_SUN:
    if (duration > PAGE_TRANSITION_MS)
    {
      currentPage = PAGE_SUN;
      pageTimer = nowMs;
      triggerZoneSetup = true;
      P.displayClear();
    }
    break;

  case PAGE_SUN:
    if (duration > SUN_PAGE_DURATION_MS)
    {
      currentPage = TRANS_TO_CLOCK;
      pageTimer = nowMs;
      P.displayClear();
    }
    break;

  case TRANS_TO_SCOPE:
    if (duration > PAGE_TRANSITION_MS)
    {
      currentPage = PAGE_SCOPE;
      pageTimer = nowMs;
      triggerZoneSetup = true;
      P.displayClear();
    }
    break;

  case PAGE_SCOPE:
    // Stay on scope until a control trigger moves it.
    break;

  case TRANS_TO_CLOCK:
    if (duration > PAGE_TRANSITION_MS)
    {
      currentPage = PAGE_CLOCK;
      pageTimer = nowMs;
      triggerZoneSetup = true;
    }
    break;
  }

  if (triggerZoneSetup)
  {
    mx->clear();
    P.begin(3);

    if (currentPage == PAGE_CLOCK)
    {
      P.setZone(0, 2, 4);
      P.setZone(1, 0, 0);
      P.setZone(2, 0, 0);

      P.setFont(0, BitPotion);
      P.setTextAlignment(0, PA_LEFT);

      updateLocalTime();
      int h = getHour();
      int h12 = (h % 12 == 0) ? 12 : (h % 12);
      lastSecond = getSecond();
      showColon = (lastSecond % 2 == 0);
      char clockStr[6];
      sprintf(clockStr, showColon ? "%02d:%02d" : "%02d %02d", h12, getMinute());
      P.displayZoneText(0, clockStr, PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(1, "", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(2, "", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT);
    }
    else if (currentPage == PAGE_WEATHER)
    {
      // PAGE 2
      P.setZone(0, 4, 4); // Hide Clock
      P.setZone(1, 1, 3); // Desc
      P.setZone(2, 0, 0); // Hide Temp (Manual Draw)

      P.setFont(1, Milford);
      P.setTextAlignment(1, PA_LEFT);

      strcpy(weatherTextBuffer, weatherDesc.c_str());

      P.displayZoneText(0, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(1, weatherTextBuffer, PA_LEFT, 40, 0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
      P.displayZoneText(2, "", PA_CENTER, 0, 0, PA_PRINT, PA_NO_EFFECT); // Clear Zone 2 for manual
    }
    else if (currentPage == PAGE_SUN)
    {
      // Use zones 0-3 for scrolling text
      P.setZone(0, 0, 3);
      P.setZone(1, 0, 0);
      P.setZone(2, 0, 0);

      P.setFont(0, Milford);
      P.setTextAlignment(0, PA_LEFT);

      SunRenderState sunState{};
      sunState.sunrise = sunriseEpoch;
      sunState.sunset = sunsetEpoch;
      sunState.now = (unsigned long)time(nullptr);
      SunInfo info = computeSunInfo(sunState);
      if (info.hasData)
      {
        if (info.hours >= 1)
          snprintf(sunTextBuffer, sizeof(sunTextBuffer), "%s in %d hours", info.targetIsSunrise ? "Sunrise" : "Sunset", info.hours);
        else
          snprintf(sunTextBuffer, sizeof(sunTextBuffer), "%s in %d minutes", info.targetIsSunrise ? "Sunrise" : "Sunset", info.minutes);
      }
      else
        snprintf(sunTextBuffer, sizeof(sunTextBuffer), "No sun data");

      P.displayZoneText(0, sunTextBuffer, PA_LEFT, 40, 0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);
      P.displayZoneText(1, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(2, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
    }
    else if (currentPage == PAGE_SCOPE)
    {
      P.setZone(0, 0, 0);
      P.setZone(1, 0, 0);
      P.setZone(2, 0, 0);
      P.displayZoneText(0, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(1, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
      P.displayZoneText(2, "", PA_LEFT, 0, 0, PA_PRINT, PA_NO_EFFECT);
    }

    mx->control(MD_MAX72XX::INTENSITY, 1);
    triggerZoneSetup = false;
  }
}

void forcePage(PageState target, unsigned long nowMs, bool withTransition)
{
  if (target != PAGE_CLOCK && target != PAGE_WEATHER && target != PAGE_SUN && target != PAGE_SCOPE)
    return;

  PageState desired = target;
  if (withTransition)
  {
    if (target == PAGE_CLOCK)
      desired = TRANS_TO_CLOCK;
    else if (target == PAGE_WEATHER)
      desired = TRANS_TO_WEATHER;
    else if (target == PAGE_SUN)
      desired = TRANS_TO_SUN;
    else
      desired = TRANS_TO_SCOPE;
  }

  if (currentPage == desired || currentPage == target)
    return;

  currentPage = desired;
  pageTimer = nowMs;
  triggerZoneSetup = true;
  P.displayClear();
}

void handleControlPackets(unsigned long nowMs)
{
  int packetSize = controlUdp.parsePacket();
  while (packetSize > 0)
  {
    uint8_t buffer[4];
    int len = controlUdp.read(buffer, sizeof(buffer));
    if (len > 0)
    {
      uint8_t code = buffer[0];
      Serial.printf("CTRL packet len=%d code=0x%02X\n", len, code);
      if (code == CTRL_CODE_PAGE_CLOCK)
      {
        forcePage(PAGE_CLOCK, nowMs, true);
      }
      else if (code == CTRL_CODE_PAGE_WEATHER)
      {
        forcePage(PAGE_WEATHER, nowMs, true);
      }
      else if (code == CTRL_CODE_PAGE_SUN)
      {
        forcePage(PAGE_SUN, nowMs, true);
      }
      else if (code == CTRL_CODE_PAGE_SCOPE)
      {
        forcePage(PAGE_SCOPE, nowMs, true);
      }
      else if (code == CTRL_CODE_NEXT_PAGE)
      {
        PageState base = currentPage;
        if (base == TRANS_TO_CLOCK)
          base = PAGE_CLOCK;
        else if (base == TRANS_TO_WEATHER)
          base = PAGE_WEATHER;
        else if (base == TRANS_TO_SUN)
          base = PAGE_SUN;
        else if (base == TRANS_TO_SCOPE)
          base = PAGE_SCOPE;

        PageState next = PAGE_CLOCK;
        if (base == PAGE_CLOCK)
          next = PAGE_WEATHER;
        else if (base == PAGE_WEATHER)
          next = PAGE_SUN;
        else if (base == PAGE_SUN)
          next = PAGE_SCOPE;
        else if (base == PAGE_SCOPE)
          next = PAGE_CLOCK;

        forcePage(next, nowMs, true);
      }
    }
    packetSize = controlUdp.parsePacket();
  }
}

void handleAudioPackets(unsigned long nowMs)
{
  int packetSize = audioUdp.parsePacket();
  while (packetSize > 0)
  {
    uint8_t buffer[128];
    int len = audioUdp.read(buffer, sizeof(buffer));
    if (len > 0)
    {
      for (int i = 0; i < TOTAL_WIDTH; i++)
      {
        int src = (i * len) / TOTAL_WIDTH;
        if (src < 0)
          src = 0;
        if (src >= len)
          src = len - 1;
        uint8_t val = buffer[src];
        if (!scopeHasData)
          scopeSmoothed[i] = val;
        else
          scopeSmoothed[i] = scopeSmoothed[i] * 0.7f + val * 0.3f;
        scopeSamples[i] = val;
      }
      scopeHasData = true;
      lastScopePacketMs = nowMs;
    }
    packetSize = audioUdp.parsePacket();
  }

  // Mark stale after 3 seconds of silence.
  if (scopeHasData && (nowMs - lastScopePacketMs > 3000))
    scopeHasData = false;
}

void updateDisplay(unsigned long nowMs)
{
  memset(screenBuffer, 0, TOTAL_WIDTH);

  if (currentPage == TRANS_TO_WEATHER || currentPage == TRANS_TO_CLOCK || currentPage == TRANS_TO_SUN || currentPage == TRANS_TO_SCOPE)
  {
    drawGlitch();
    for (int i = 0; i < TOTAL_WIDTH; i++)
      mx->setColumn(i, screenBuffer[i]);
    return;
  }

  if (P.displayAnimate())
  {
    if (currentPage == PAGE_WEATHER)
    {
      if (P.getZoneStatus(1))
        P.displayReset(1);
    }
    else if (currentPage == PAGE_SUN)
    {
      if (P.getZoneStatus(0))
        P.displayReset(0);
    }
  }

  if (currentPage == PAGE_CLOCK)
  {
    updateLocalTime();
    if (getSecond() != lastSecond)
    {
      lastSecond = getSecond();
      int h = getHour();
      bool isPM = (h >= 12);
      int h12 = (h % 12 == 0) ? 12 : (h % 12);
      showColon = (lastSecond % 2 == 0);
      static char clockStr[10];
      sprintf(clockStr, showColon ? "%02d:%02d" : "%02d %02d", h12, getMinute());
      P.setTextBuffer(0, clockStr);
      P.displayReset(0);
    }
    updateModeSwitcher(nowMs);

    if (currentMode == MODE_SCRAMBLE)
    {
      if (nowMs - lastScrambleTick > SCRAMBLE_DELAY)
      {
        lastScrambleTick = nowMs;
        currentFrame++;

        for (int k = 0; k < 4; k++)
          scrambleIndices[k] = random(0, 15);
      }

      bool allDone = true;
      for (int i = 0; i < 4; i++)
      {
        if (currentFrame < resolveFrame[i])
          allDone = false;
      }
      if (allDone)
      {
        currentMode = nextMode;
        modeTimer = nowMs;
      }
    }

    ClockRenderState clockState{};
    clockState.hour = getHour();
    clockState.minute = getMinute();
    clockState.second = getSecond();
    clockState.day = getDay();
    clockState.month = getMonth();
    clockState.weekday = getWeekday();
    clockState.showColon = showColon;
    clockState.mode = currentMode;
    clockState.currentFrame = currentFrame;
    for (int i = 0; i < 4; i++)
    {
      clockState.resolveFrame[i] = resolveFrame[i];
      clockState.scrambleIndices[i] = scrambleIndices[i];
      clockState.targetBitmaps[i] = targetBitmaps[i];
    }
    drawClock(clockState, DIGITS, LETTERS, DAY_MAP, screenBuffer, TOTAL_WIDTH);

    // Animate a bouncing dot along columns 8-15 (module 1) with gravity-like motion
    if (lastBounceTick == 0)
      if (lastBounceTick == 0)
      {
        lastBounceTick = nowMs;
        bounceVel = BOUNCE_LAUNCH_V;
      }

    unsigned long dtMs = nowMs - lastBounceTick;
    if (dtMs > BOUNCE_MAX_DT)
      dtMs = BOUNCE_MAX_DT;
    lastBounceTick = nowMs;

    float dt = dtMs / 1000.0f; // convert to seconds

    bounceVel += -BOUNCE_G_MAG * dt; // constant pull toward left
    bouncePos += bounceVel * dt;

    // Bounce off the ground (left wall)
    if (bouncePos < BOUNCE_START_COL)
    {
      bouncePos = BOUNCE_START_COL;
      bounceVel = BOUNCE_LAUNCH_V;
    }

    // Clamp at right wall just in case
    if (bouncePos > BOUNCE_END_COL)
      bouncePos = BOUNCE_END_COL;

    int col = int(lround(bouncePos));
    if (col < BOUNCE_START_COL)
      col = BOUNCE_START_COL;
    else if (col > BOUNCE_END_COL)
      col = BOUNCE_END_COL;

    screenBuffer[col] |= 0x40; // second row from bottom on rotated matrix

    int hourNow = getHour();
    bool isPM = (hourNow >= 12);

    screenBuffer[17] |= isPM ? 0x51 : 0x55;
    screenBuffer[16] |= isPM ? 0x77 : 0x72;

    for (int i = 0; i < 18; i++)
      mx->setColumn(i, screenBuffer[i]);
  }

  else if (currentPage == PAGE_WEATHER)
  {
    WeatherRenderState weatherState{};
    weatherState.data.valid = true;
    weatherState.data.id = weatherIconID;
    weatherState.data.desc = weatherDesc;
    weatherState.data.feelsLike = feelsLikeTemp;
    weatherState.iconId = weatherIconID;

    drawWeather(weatherState, WEATHER_ICONS, DIGITS, screenBuffer, TOTAL_WIDTH);

    // Push Module 4 and Module 0
    for (int i = 32; i < 40; i++)
      mx->setColumn(i, screenBuffer[i]);
    for (int i = 0; i < 8; i++)
      mx->setColumn(i, screenBuffer[i]);
  }
  else if (currentPage == PAGE_SUN)
  {
    SunRenderState sunState{};
    sunState.sunrise = sunriseEpoch;
    sunState.sunset = sunsetEpoch;
    sunState.now = (unsigned long)time(nullptr);

    SunInfo info = computeSunInfo(sunState);
    if (info.hasData)
    {
      if (info.hours >= 1)
        snprintf(sunTextBuffer, sizeof(sunTextBuffer), "%s in %d hours", info.targetIsSunrise ? "Sunrise" : "Sunset", info.hours);
      else
        snprintf(sunTextBuffer, sizeof(sunTextBuffer), "%s in %d minutes", info.targetIsSunrise ? "Sunrise" : "Sunset", info.minutes);
    }
    else
      snprintf(sunTextBuffer, sizeof(sunTextBuffer), "No sun data");

    P.setTextBuffer(0, sunTextBuffer);

    drawSun(info, MOON_SUN, screenBuffer, TOTAL_WIDTH);
    for (int i = 32; i < 40; i++)
      mx->setColumn(i, screenBuffer[i]);
  }
  else if (currentPage == PAGE_SCOPE)
  {
    ScopeRenderState scopeState{};
    // Decay smoothed samples toward midline when idle
    if (!scopeHasData)
    {
      for (int i = 0; i < TOTAL_WIDTH; i++)
        scopeSmoothed[i] = scopeSmoothed[i] * 0.95f + 128.0f * 0.05f;
    }
    static uint8_t displaySamples[TOTAL_WIDTH];
    for (int i = 0; i < TOTAL_WIDTH; i++)
    {
      float v = scopeSmoothed[i];
      if (v < 0.0f)
        v = 0.0f;
      if (v > 255.0f)
        v = 255.0f;
      displaySamples[i] = (uint8_t)v;
    }
    scopeState.samples = displaySamples;
    scopeState.sampleCount = TOTAL_WIDTH;
    scopeState.hasData = scopeHasData;
    drawScope(scopeState, screenBuffer, TOTAL_WIDTH);
    for (int i = 0; i < TOTAL_WIDTH; i++)
      mx->setColumn(i, screenBuffer[i]);
  }
}

